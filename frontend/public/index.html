<!DOCTYPE html>
<html lang="en">
  <title> </title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/tachyons/css/tachyons.min.css">
  <style>
.board {
  user-select: none;
}

text {
  font-family: helvetica;
  font-weight: bold;
}
body {
  background-color: #1a1a1a
}
  </style>
  <body>
    <div class='board' id='board'>
    </div>
    <!--
    <svg viewBox="0 0 150 150">
      <svg viewBox="0 0 100 100" width='10' height='10'>
        <rect stroke-width='3' stroke='black' width='100' height='100' fill='tomato'></rect>
        <text class='letter' fill='white' x='50' y='57' font-size='80' text-anchor='middle' alignment-baseline='middle'>X</text>
        <text fill='white' x='86' y='86' font-size='20' text-anchor='middle' alignment-baseline='middle'>8</text>
      </svg>
      <svg x="10" viewBox="0 0 100 100" width='10' height='10'>
        <rect stroke-width='3' stroke='black' width='100' height='100' fill='tomato'></rect>
        <text class='letter' fill='white' x='42' y='57' font-size='80' text-anchor='middle' alignment-baseline='middle'>Q</text>
        <text fill='white' x='82' y='86' font-size='20' text-anchor='middle' alignment-baseline='middle'>10</text>
      </svg>
      <svg x="20" viewBox="0 0 100 100" width='10' height='10'>
        <rect stroke-width='3' stroke='black' width='100' height='100' fill='tomato'></rect>
        <text class='letter' fill='white' x='42' y='57' font-size='80' text-anchor='middle' alignment-baseline='middle'>Z</text>
        <text fill='white' x='82' y='86' font-size='20' text-anchor='middle' alignment-baseline='middle'>10</text>
      </svg>
    </svg>
    -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
<script>
  const gridSize = 15

  data = []
  for (let x = 0; x < gridSize; x++) {
    for (let y = 0; y < gridSize; y++) {
      let content = {"letter": "", "score": 0, "bonus": "none"}

      if (x == 0 && y == 0) {
        content = {"bonus": "TW"}
      } else if (x == 1 && y == 1) {
        content = {"bonus": "DW"}
      } else if (x == 3 && y == 3) {
        content = {"bonus": "TL"}
      } else if (x == 4 && y == 0) {
        content = {"bonus": "DL"}
      } else if (x == 7 && y == 7) {
        content = {"bonus": "★"}
      } else if (x == 2 && y == 6) {
        content = {"letter": "X", "score": 8}
      } else if (x == 3 && y == 6) {
        content = {"letter": "A", "score": 1}
      } else if (x == 4 && y == 6) {
        content = {"letter": "W", "score": 4}
      } else if (x == 3 && y == 7) {
        content = {"letter": "Q", "score": 10}
      } else if (x == 3 && y == 8) {
        content = {"letter": "Z", "score": 10}
      }
      data.push(
        deepmerge({"xPos": x, "yPos": y}, content)
      )
    }
  }

// gold #d59120
// green #759900
// red #ac524f
// another green #92B166
// background #DEE3E6
const BONUS_COLORS = {
  "none": "#738896",
  "TW": "#ac524f",
  "DW": "#ef928f",
  "TL": "#759900",
  "DL": "#69D2E7",
  "★": "#cc12bf",
  "letter": "#d59120"
}

// https://www.colourlovers.com/palette/92095/Giant_Goldfish
const BONUS_COLORS_OLD = {
  "none": "#fff9e5",
  "TW": "#FA6900",
  "TL": "#F38630",
  "DW": "#69D2E7",
  "DL": "#A7DBD8",
  "★": "#69D2E7",
  "letter": "tomato"
}

const DEFAULT_KERNING = {
  "letter": {"x": 0.50, "y": 0.55},
  "score": {"x": 0.86, "y": 0.86}
}
const KERNING = {
  /*
  "Z": {
    "letter": {"x": 0.42},
    "score": {"x": 0.82}
  },
  "Q": {
    "letter": {"x": 0.42},
    "score": {"x": 0.82}
  }*/
}

function isMergeableObject(val) {
    var nonNullObject = val && typeof val === 'object'

    return nonNullObject
        && Object.prototype.toString.call(val) !== '[object RegExp]'
        && Object.prototype.toString.call(val) !== '[object Date]'
}

function emptyTarget(val) {
    return Array.isArray(val) ? [] : {}
}

function cloneIfNecessary(value, optionsArgument) {
    var clone = optionsArgument && optionsArgument.clone === true
    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
}

function defaultArrayMerge(target, source, optionsArgument) {
    var destination = target.slice()
    source.forEach(function(e, i) {
        if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument)
        } else if (isMergeableObject(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument)
        } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument))
        }
    })
    return destination
}

function mergeObject(target, source, optionsArgument) {
    var destination = {}
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function (key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument)
        })
    }
    Object.keys(source).forEach(function (key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument)
        } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument)
        }
    })
    return destination
}

function deepmerge(target, source, optionsArgument) {
    var array = Array.isArray(source);
    var options = optionsArgument || { arrayMerge: defaultArrayMerge }
    var arrayMerge = options.arrayMerge || defaultArrayMerge

    if (array) {
        return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)
    } else {
        return mergeObject(target, source, optionsArgument)
    }
}
const getKerning = letter => {
  var kerning = KERNING[letter] || DEFAULT_KERNING

  return deepmerge(DEFAULT_KERNING, kerning)
}

// 1. Fill out the grid.
// 2. Experiment with colors
// 3. Drag and drop

    //kerning[d.letter]
var board = d3.select("#board")
  .append("svg")
  .attr("viewBox", "0 0 15 15")

var cell = board.selectAll(".cell")
  .data(data)
  .enter()
  .append("svg")
    .attr("class", "cell")
    .attr("viewBox", "0 0 1 1")
    .attr("width", 1)
    .attr("height", 1)
    .attr("x", d => d.xPos)
    .attr("y", d => d.yPos)

cell.append("rect")
  .attr("width", 1)
  .attr("height", 1)
  .attr("fill", d => d.letter ? BONUS_COLORS["letter"] : BONUS_COLORS[d.bonus])
  .attr("shape-rendering", "crispEdges")
  .attr("stroke-width", 0.02)
  .attr("stroke", "#1a1a1a")
  .attr("opacity", d => d.bonus == "none" ? "0.5" : "1.0")

cell.filter(d => d.letter).append("text")
  .html(d => d.letter)
  .attr("x", d => getKerning(d.letter)["letter"]["x"])
  .attr("y", d => getKerning(d.letter)["letter"]["y"])
  .attr("font-size", 0.80)
  .attr("fill", "white")
  .attr("text-anchor", "middle")
  .attr("alignment-baseline", "middle")

cell.filter(d => d.bonus && d.bonus != "none").append("text")
  .html(d => d.bonus)
  .attr("x", d => 0.50)
  .attr("y", d => 0.53)
  .attr("font-size", 0.45)
  .attr("fill", "white")
  .attr("text-anchor", "middle")
  .attr("alignment-baseline", "middle")

// SCORE
cell.filter(d => d.score).append("text")
  .html(d => d.score)
  .attr("x", d => getKerning(d.letter)["score"]["x"])
  .attr("y", d => getKerning(d.letter)["score"]["y"])
  .attr("fill", "white")
  .attr("text-anchor", "middle")
  .attr("alignment-baseline", "middle")
  .attr("font-size", 0.20)
  .attr("letter-spacing", "-0.02")
</script>

  </body>
</html>
